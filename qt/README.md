# Собственная сборка Qt

В этом проекте мы соберём `Qt` своими руками с рядом необходимых зависимостей.
Ознакомьтесь с проектом [`OpenSUSE`](../opensuse/README.md) в плане настройки
среды. Интегрируйте переменные из локального файла [`env.sh`](env.sh) в
актуальный файл `env.sh` в вашей системе.

# Содержание

- [Собственная сборка Qt](#собственная-сборка-qt)
- [Содержание](#содержание)
- [Версионность](#версионность)
- [Qt](#qt)
  - [Репозиторий и готовые сборки](#репозиторий-и-готовые-сборки)
  - [Небольшое исследование](#небольшое-исследование)
  - [Зависимости Qt](#зависимости-qt)
  - [Подготовка Qt](#подготовка-qt)
  - [Переход на другие ветки и теги](#переход-на-другие-ветки-и-теги)
  - [Заплатка Qt](#заплатка-qt)
  - [Модули Qt](#модули-qt)
  - [Сборка Qt](#сборка-qt)
  - [Замечания Qt](#замечания-qt)
- [OpenCV](#opencv)
  - [Подготовка OpenCV](#подготовка-opencv)
  - [Сборка OpenCV](#сборка-opencv)
- [OpenSSL](#openssl)
  - [Подготовка OpenSSL](#подготовка-openssl)
  - [Сборка OpenSSL](#сборка-openssl)
- [LLVM](#llvm)
  - [Подготовка LLVM](#подготовка-llvm)
  - [Сборка LLVM](#сборка-llvm)
- [Полезные ссылки](#полезные-ссылки)

# Версионность

Далее фиксация версий ПО для обеих сред. В таблице так же приведены переменные
среды хранящие версию:

> При изменении версии в данной таблице, не забывайте пожалуйста так же
> актуализировать значения переменных в файле [`env.sh`](env.sh)

| ПО        | `Git ref`           | Переменная |
| :-------- | :------------------ | :--------- |
| `Qt`      | `v5.15.12-lts-lgpl` | `QT_REF`   |
| `OpenCV`  | `4.6.0`             | `CV_REF`   |
| `OpenSSL` | `openssl-3.2.1`     | `SL_REF`   |
| `LLVM`    | `llvmorg-16.0.1`    | `LL_REF`   |

# Qt

В общем в `OpenSUSE` оказался целый ряд пакетов со сборкой `Qt5` для
разработки, к примеру: `libQt5Core-devel`. На случай если вам всё же придётся
собирать `Qt` вручную, перед вами данная глава. Возможно так же у вас
возникнут трудности с `OpenSSL`. Вы можете или [собрать](#openssl) собственную
сборку или установить пакет `libopenssl-3-devel`. Но в таком случае, вы
сталкнётесь с [ошибками](qt.ld.err) линковки с `zlib`.

> TODO: решить проблемы линковки с `zlib` при сборке `Qt` с
> `libopenssl-3-devel`

`Qt` можно собрать из двух источников:

1. Репозиторий
2. Скаченный архив

Репозиторий `Qt` представляет из себя композицию из главного репозитория с
подмодулями `git`-а. Скаченный архив обычно содержит `working tree`
определённого тега всей этой композиции, и находится в формате `.tar.gz`.

> В сети на данный момент официально есть только репозиторий содержащий теги
> `Qt 5` и `Qt 6` (в рамках одной композиции). Даже после известных событий
> и ограничений от компании `Qt` в отношении некоторых государств на скачивание
> своих продуктов, доступ к самому [репозиторию][1] под лицензией `LGPL`
> открыт, что не может не радовать

При этом репозитория `Qt 4` в свободном доступе нет. Есть только архивы, их
можно скачать лишь с сайта `Qt`, но скачивание заблокированно. Ещё до блокировки
я успела скачать весьма святой для нас архив:
`qt-everywhere-opensource-src-4.7.4.tar.gz`, мы можем им пользоваться, так как
содержимое под лицензией `LGPL`, но не сможем больше его скачать легально, без
прокси и `VPN`. По сему это тархив нужно хранить и расположить где то в
централизованном месте.

Я думала (и даже реализовала задуманное) - загрузить содержимое в виде
репозитория на `GitHub`, идея особенно привлекательна учитывая, что при
создании образа `Docker`-а нужна лишь команда `git clone`. Но я разочаровалась
в этой идее, так как репозиторий предполагает наличие всех веток и тегов версий
проекта, плюс репозиторий `Qt`, как сказанно выше - это композиция. Такой
самопальный статичный репозиторий, который не будет изменяться, слишком не
соответствует правилам красоты и эстетики, и решено было оставить код `Qt 4` в
виде архивов.

`Qt 4` не собирается на `OpenSuse 15.3`
(и `14.x`, и `13.x` скорее всего и ещё и ещё), но собирается на `OS` конца
90-х. На новой `OS` вы получите следующую ошибку:

> error: flexible array member ‘inotify_event::name’ not at end of
> ‘struct QMapPayloadNode<int, inotify_event>’

Сборка `Qt 4` необходима для запуска компиляции нынешней версии проекта на
`GitLab CI` в контейнере `Docker`-а на `appsrv-1`, и подробно рассмотрена
далее.

Перед сборкой `Qt` соберите [`OpenSSL`](#openssl). Обратите внимание на опцию
`-I /opt/openssl/include` в настройках `configure`. Прочитайте [подробнее][3] о
сборке `Qt` с `OpenSSL`.

> TODO: проверить, от куда `Qt` тянет библиотеки `OPenSSL`, если мы казываем
> при сборке лишь папку с заголовками через опцию `-I`

## Репозиторий и готовые сборки

> Важная ремарка! По неустановленным причинам, но предположительно в
> коммерческих целях, `Qt` достаточно трудно собрать из `OpenSource`-ного
> репозитория (иного у нас нет)

Большинство веток и тегов просто не собираются. Проще всего было собрать тот
набор исходников, которые скачивался с файлового хранилища `release`-ов. Он
распологался на хосте `download.qt.io` по пути `official_releases/qt/`. Сейчас
доступ туда закрыт.

При этом я не нашла *формальной* разницы между содержимым репозитория
переключённого на соответствующий тег и содержимым разархивированного
репозитория с файлового хранилища `Qt`. *Формальной*, в плане файлов
учавствующих в процессе сборки.

**Далее исследование, которое я провела**.

## Небольшое исследование

Создаём скрипт сравнений репозитория и распаковоного архива:

```sh
#!/bin/sh

# Файл diff.sh

diff -qr \
  --exclude=".QT-*" \
  --exclude=".git" \
  --exclude=".gitignore" \
  --exclude=".gitattributes" \
  --exclude=".commit-template" \
  --exclude=".tag" \
  $1 \
  $REPOS/$QT_SLUG
```

Скачиваем `release`, к примеру `5.15.2` и разархивируем его содержимое в папку:
`/opt/qtsrc`, созданную раннее:

```sh
cd /opt/qtsrc
REPO=qt-everywhere-src
MAJOR=5.15
MINOR=1
VER=${MAJOR}.${MINOR}
URL_PROTO=https
URL_HOST=download.qt.io
URL_PATH=official_releases/qt/${MAJOR}/$VER/single
URL_FILE=${REPO}-${$VER}.tar.xz
URL=$URL_PROTO://$URL_HOST/$URL_PATH/$URL_FILE
wget $URL
tar -xvf $URL_FILE
ls /opt/qtsrc/$URL_FILE
```

> Доступ к `release`-ам из россии всё же закрыли, можно собирать лишь из
> репозитория

Операции делаем во временной папке.

```sh
mkdir /tmp/qtdiff
cd /tmp/qtdiff
vim diff.sh
chmod u+x diff.sh
```
Переключаем наш основной репозиторий на соотетствующий тег:

*Подробнее обо всех коммандах работы с репозиторием `Qt` смотрите ниже*.

```sh
cd $REPOS
git clone git://code.qt.io/qt/qt5.git
git checkout v5.15.2
git submodule update --init --recursive --force
git submodule foreach --recursive "git clean -dfx" && git clean -dfx
untracked
git status
# Чистим в ручную, всё что не очистилось, как описано ниже
```

Создаём файл сравнения:

```sh
./diff.sh /opt/qtsrc/qt-everywhere-src-5.15.2 > diff_5.12.2.log
```

Переключаем наш основной репозиторий на иной, к примеру `v5.6.0` тег:

```sh
cd $REPOS/$QT_SLUG
git checkout v5.6.0
# Выполняем соответствующие действия, как в прошлый раз
```

Создаём второй файл сравнения:

```
./diff.sh /opt/qtsrc/qt-everywhere-src-5.15.2 > diff_5.6.0.log
```

Изучив оба файла, можно достаточно точно сказать, что состояния тегов в
репозитори соответствют состояниям `release`-ов в файловом хранилище `Qt`.

> Резюмируя сказанное: если вы работаете с репозиторием, переключайте на
> `teg`-и только в соответствии с версиями архивов с файлового хранилища
> `release`-ов `Qt`

## Зависимости Qt

> `Qt` можно установить с помощью отдельного файла установщика, но при этом
> потребуется нерационально большое дисковое пространоство, что идёт в разрез
> с принципами систем *АПК* и *встроенных* (`embedded`) систем, поэтому, а так
> же для полного соблюдения `LGPL`, мы устанавливаем `Qt` через сборку
> исходников

Убедитесь, что установлены необходимые пакеты.

Общие:

```sh
sudo zypper in \
  libzstd-devel
```

`Libxcb`:

> TODO: перепроверить

```sh
sudo zypper in \
  xorg-x11-libxcb-devel \
  xcb-util-devel \
  xcb-util-image-devel \
  xcb-util-keysyms-devel \
  xcb-util-renderutil-devel \
  xcb-util-wm-devel \
  libxkbcommon-x11-devel \
  libxkbcommon-devel \
  libXi-devel \
  libzstd-devel
```

`Qt WebKit`:

> TODO: перепроверить

```sh
sudo zypper in flex bison gperf libicu-devel
```

Не устанавливайте `Qt WebEngine` из за конфликтов. При сборке `Qt WebEngine` вы
можете столкнуться с ещё не решённой ошибкой:

> No package 'nss' found\
> Could not run pkg-config.

Следующие комманды **НЕ** помогают:

```sh
pip install nss
sudo zypper in libnss_nis2
```

## Подготовка Qt

Склонируйте репозиторий и выберите нужный тег:

```sh
cd $REPOS
git clone git://code.qt.io/qt/$QT_SLUG.git && cd $QT_SLUG
git checkout $QT_REF
```

Проект имеет большое количество веток и тегов. Не всё `ref`-ы консистенты,
особенно неконсистентными могут быть `HEAD`-ы веток. Но даже если исходники в
`ref`-е консистенты, есть большой шанс, что нынешнее состояние вашей системы не
совсем подходит для данного состояния репозитория. Вам придётся немного
потрудиться, дабы найти соответствующий тег для соответствующей версии
дистрибутива. Вам поможет [список версий][4] проекта исходников `Qt`. Сразу
переходите к части `Tag`.

Вы можете пролистать и выбрать иные ветку или тег, затем переключится на неё,
например `v5.15.2`:

```sh
# Выберите ветку
git branch -r
# Или тег
git tag
# Переключитесь на ветку или тег
git checkout v5.15.2
```

Докачиваем недостающие репозитории, и исключаем `WebEngine`. для этого
запускаем скрипт `init-repository`. Процесс `git submodule update` может
занять около получаса, в основном из за ограничения по скорости скачивания
со стороны сервера.

> Для тегов пятой версии `Qt` скрипт `init-repository` не всегда срабатывает,
> по-этому далее мы будем использовать так же команду самого `git`-а

```sh
# Запускаем команду git-а
git submodule update --init --recursive --force
# Запускаем основной скрипрт и исключаем WebEngine
perl init-repository --module-subset=default,-qtwebengine -f
```

Проверить, что всё хорошо, конечно можно командой `git status` и отсутствием
красного цвета в выводе.

## Переход на другие ветки и теги

Если вы переходите на другую ветку/тег, а вам с большщой степенью вероятности
придётся это делать, то вам нужно очистить данные предыдущего сотояния.

Для этого используется рекурсивная команда:

```sh
git submodule foreach --recursive "git clean -dfx" && git clean -dfx
```

При этом несмотря на ключи `-dfx` в репозитори `Qt` могут остаться файлы сироты
в модулях и корне проекта `Qt`, как уже сказано, репозиторий `Qt` представляет
из себя композитный репозиторий, где в каждом модуле так же есть папка `.git`.

В этом случае мы получим вот такой вывод, обратите внимание на
*untracked content* в выводе:

```sh
git status
HEAD detached at v5.15.2
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)
        modified:   qt3d (untracked content)
        modified:   qttools (untracked content)

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        qt5compat/
        qtcoap/
```

Тогда требуется поочерёдно войти в каждый модуль из верхней части вывода -
`Changes not staged for commit`, и удалить файлы сироты с помощью `alias`-а
`untracked`, созданный в `~/.bashrc` ранее:

> TODO: написать скрипт для рекурсивного удаления неподконтрольных `git`-у
> файлов

```sh
cd qt3d
git status
HEAD detached at 34171b1d9
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        src/3rdparty/assimp/src/

rm -rf src/3rdparty/assimp/src/
cd ..
cd qttools
git status
...
untracked
# Вернёмся обратно
cd ..
```

Файлы сироты уходящие из под котроля гита располагаются рекурсивно. Мы начали с
модулей, теперь возвращаемся в корень, и выполняем аналогичное действие для
файлов из нижней части вывода - `Untracked files`, если такие имеются:

```sh
git status
untracked
```

Если `alias` `untracked` по какой то причине не сработает, воспользуйтесь более
базовой конструкцией команд:

```sh
git status | \
  sed -n '/Untracked files/,$p' | \
  tail -n +3 | \
  head -n -2 | \
  sed 's/^[ \t]*//' | \
  xargs rm -rf
```

Далее снова выполните:

```sh
# Запускаем команду git-а
git submodule update --init --recursive --force
# Запускаем основной скрипрт и исключаем WebEngine
perl init-repository --module-subset=default,-qtwebengine -f
```

И обязательно удалите всё содержимое папки, где непосредственно происходит
сборка: `QT_BUILD`.

## Заплатка Qt

Как уже было сказано крайне тяжело найти *тег* `git`-а в котором ваша сборка
`Qt` была бы успешной на конкретной `ОС`. Даже найдя самый оптимальный вариант,
вам придётся поотключать большо йнабор модулей, которые не смогут собраться.

Как минимум на актуальном для данного мануала *теге* `Qt` библиотека
`xkbcomon` более новой версии чем ожидается в коде, что не позволяет собрать
модуль `xcb` (второй раз чере `c`). Данный модуль необходим для `Guitar`.

В свете этого была создана *заплатка* (`patch`) решающая данную проблему. Её
необходимо применить:

```sh
cd $REPOS/$QT_SLUG/qtbase
git apply $REPOS/$SS_SLUG/opensuse/xcb.patch
```

## Модули Qt

`Qt` крайне большая экосистема и некоторые модули стоит обойти. Часть из них
не пригодиться в ваших проектах, как напримет `qt3d` если вы не разрабатываете
трёхмерную реальностью. Часть не релевантна, как например `qtwinextras` на
`Linux`-е, часть простоне соберётся, как например `qtdocgallery`. Для того,
чтобы исключить модуль из сборки, вам нужно добавить параметр `-skip <repo>`
в `alias` `qt5configure`. Ниже список внутренних репозиториев, актуальных на
тег указанный в разделе [*Версионность*](#версионность), их размер, и признак
включения в сборку.

> При каждом добавлении параметра `-skip <repo>` и переконфигурировании сборки
> у вас будет происходит полная пересборка проекта

| Размер  | Репозиторий          |      |
| :------ | :------------------- | :--- |
| `240M`  | `qt3d`               |      |
| `2.2M`  | `qtactiveqt`         | +    |
| `2.5M`  | `qtandroidextras`    |      |
| `335M`  | `qtbase`             | +    |
| `15M`   | `qtcanvas3d`         |      |
| `12M`   | `qtcharts`           |      |
| `13M`   | `qtconnectivity`     | +    |
| `21M`   | `qtdatavis3d`        |      |
| `243M`  | `qtdeclarative`      | +    |
| `12M`   | `qtdoc`              | +    |
| `1.5M`  | `qtdocgallery`       |      |
| `1000K` | `qtfeedback`         | +    |
| `1.3M`  | `qtgamepad`          |      |
| `51M`   | `qtgraphicaleffects` | +    |
| `11M`   | `qtimageformats`     | +    |
| `73M`   | `qtlocation`         |      |
| `1.1M`  | `qtlottie`           |      |
| `1.6M`  | `qtmacextras`        |      |
| `34M`   | `qtmultimedia`       | +    |
| `700K`  | `qtnetworkauth`      | +    |
| `12M`   | `qtpim`              | +    |
| `2.3M`  | `qtpurchasing`       |      |
| `103M`  | `qtqa`               | +    |
| `159M`  | `qtquick3d`          |      |
| `30M`   | `qtquickcontrols`    | +    |
| `62M`   | `qtquickcontrols2`   | +    |
| `396K`  | `qtquicktimeline`    | +    |
| `3.7M`  | `qtremoteobjects`    | +    |
| `648K`  | `qtrepotools`        | +    |
| `41M`   | `qtscript`           | +    |
| `5.2M`  | `qtscxml`            | +    |
| `8.5M`  | `qtsensors`          | +    |
| `3.5M`  | `qtserialbus`        | +    |
| `3.2M`  | `qtserialport`       | +    |
| `656K`  | `qtspeech`           |      |
| `15M`   | `qtsvg`              | +    |
| `4.9M`  | `qtsystems`          | +    |
| `56M`   | `qttools`            | +    |
| `22M`   | `qttranslations`     |      |
| `34M`   | `qtvirtualkeyboard`  | +    |
| `6.3M`  | `qtwayland`          |      |
| `2.9M`  | `qtwebchannel`       |      |
| `2.0G`  | `qtwebengine`        |      |
| `480K`  | `qtwebglplugin`      |      |
| `3.2M`  | `qtwebsockets`       | +    |
| `812K`  | `qtwebview`          |      |
| `4.7M`  | `qtwinextras`        |      |
| `3.8M`  | `qtx11extras`        | +    |
| `292M`  | `qtxmlpatterns`      | +    |

## Сборка Qt

Сборка `Qt` у нас располагается в папке `INSTALLS/QT_SLUG`. Убедитесь, что
переменные `QMAKEPATH` и `QMAKEFEATURES` не установлены. При этом в
`~/.bashrc` *применяется* (`source`) скрипт [`env.sh`](env.sh).

Запустите настройку сборки из созданной ранее папки с помощью `alias`-а
`qt5config`. Очень вероятно, что вам потребуется модифицировать `alias`
`qt5config`. Вашему вниманию предлагаются следующие информативные выводы
команды `configure`. Все распечатки взяты с тега `QT_REF`:

* [Вывод](configure.help) `configure -h`
* [Вывод](configure.features) `configure -list-features`
* [Вывод](configure.libraries) `configure -list-libraries`

Любой запуск `configure` выполняйте толлько в папке `QT_BUILD`. Запускаем
подготовку к сборке:

```sh
cd $BUILDS/$QT_SLUG
# Настраиваем сборку
qt5config
```

Вы можете до запуска `qt5config` запустить любой информативный вывод, дабы
система выполнила начальную фазу сборки (инициализацию) в папке `qtbase`,
например:

```sh
# Выполняем инициализацию через вызов информативного вывода
$REPOS/$QT_SLUG/configure -h
```

Для отладки процесса настройки сборки и перенаправления вывода в удобный
текстовый редактор воспользуйтесь следующими конструкциями. Так же добавьте
опцию `-v` к команде `configure`:

```sh
# Запускаем сборку, добавьте -v к команде configure в alias-е qt5config
qt5config > log.log 2>&1
# Пока идёт настройка вы можете в параллельном табе наблюдать за процессом
tail -f log.log
# Вернитесь в основной таб и убедитесь, что нет ошибок, или решите проблемы
less log.log
# Так же можно сразу вывести вывод в less
qt5config 2>&1 | less
```

В случае, если нужно собрать `Qt` под иную архитектуру, то необходимо добавить
параметр `-platform` с требуемой архитектурой в вызове скрипта `configure`.
Список поддерживаемых архитектур, можно узнать в следующей распечатке:

```sh
ls /opt/qtsrc/qt-everywhere-opensource-src-4.7.4/mkspecs
```

Если вы не использовали опцию `-confirm-license` в `configure`, примите условия
лицензии. Далее начнётся конфигурация для последующей сборки. По завершении
внимательно прочитайте конец вывода. Он должен быть чем то вроде:

```
Qt is now configured for building. Just run 'gmake'.
Once everything is built, Qt is installed.
You should NOT run 'gmake install'.
Note that this build cannot be deployed to other machines or devices.

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
```

Запустите `gmake` указав максимальное количеством ядер процессоров, для
ускорения процесса. Несмотря на сообщение выше, нам всё же нужно достигнуть
цели `install`, так как папка установки не находится в папке сборки:

```sh
gmake -j$(nproc)
sudo gmake install
```

Для ранних версий `Qt`, выпоолните сборку с помощью `make` с той же опцией
распараллеливания сборки:

```sh
make -j$(nproc)
sudo make install
```

> Если происходит сбой сборки, и вам нужна ошибка, коорая привела к сбою,
> запустите `make` без параметра `-j`, что бы избежать распаралеливание и
> оставить ошибку в последних строчках вывода.

Если нужно переключится на другую ветку или тег, к примеру `v6.2.3`,
[смотрите](#переход-на-другие-ветки-и-теги) инструкцию выше.

> Если вы собираете в распараллеленом режиме (опция `-j`), и сборка в одном из
> потоков упала, то при возобновлении, хоть и будучи заранее провальной, сборка
> вновь может занять очень много времени, так как, как это можно предположить,
> каждый раз создаётся разная последовательность собираемых модулей

В успешно собранном варианте размер папок и количество файлов будут примерно
следующее:

```sh
sized
7.5G    .
countf
19378
```

## Замечания Qt

Для того, чтобы передать в `qmake` дополнительную конфигурацию, выполните
команду на подобии:

```sh
qmake CONFIG+=debug GitQlient.pro
```

---
При отладке приложения, устновите переменную `QT_DEBUG_PLUGINS` в `1`. Допустим
вы отлаживаете запуск `Qt` приложения `konsole`. Вы можете установить переменную
одним из двух способов:

Экспортировать её глобально, и затем запустит приложение:

```sh
export QT_DEBUG_PLUGINS=1
konsole
```

Экспортировать локально для конкретного приложения:

```sh
QT_DEBUG_PLUGINS=1 konsole
```

# OpenCV

`OpenCV` собирается с [официального сайта][5].

## Подготовка OpenCV

Склонируйте репозиторий и выберите нужную ветку:

```sh
cd $REPOS
git clone https://github.com/opencv/$CV_SLUG.git && cd $CV_SLUG
git checkout $CV_REF
```

## Сборка OpenCV

Запускаем подготовку к сборке:

```sh
cd $BUILDS/$CV_SLUG
# Запускаем сборку
cv4config
```

Запускаем сам процесс сборки:

```sh
make -j$(nproc)
sudo make install
```

# OpenSSL

В свете отсутствия соответствующего нашим требованиям `libssl` в `OpenSUSE`,
нам понадобится ручная сборка `OpenSSL` для `Qt` и иных проектов. Результат
сборки `OpenSSL` мы расположим отдельно от стандартного дерева `/usr`, дабы не
нарушить консистентность всего дестрибутива `OpenSUSE`.

## Подготовка OpenSSL

Склонируйте репозиторий и выберите нужную ветку:

```sh
cd $REPOS
git clone https://github.com/openssl/$SL_SLUG.git && cd $SL_SLUG
git checkout $SL_REF
```

## Сборка OpenSSL

Запустите подготовку к сборке:

```sh
cd $BUILDS/$SL_SLUG
# Запускаем сборку
sl3config
```

Вы можете проверить настройку с помощью:

```sh
perl configdata.pm --dump | less
```

Запустите сам процесс сборки и установку:

```sh
make -j$(nproc)
sudo make install
```

# LLVM

`LLVM` как надпроект `libclang` это решение для разбора кода `C/C++`, что
позволяет интерактивным средам (`IDE`) совершать навигацию по коду и авто
Проект `LLVM` пригодится нам для сборки `QtDoc` а так же создания
[интерактивной](../vimide/README.md#ctrlk) среды разработки.

> TODO: Пока проект так и не удалось собрать; довести эту задачу до решения

## Подготовка LLVM

Репозиторий проекта очень большой. В своём чистом виде он берёт более 4 `Gb`.
По сему мы воспользуемся опцией `shallow clone`, что сократит размер на 2 `Gb`.
Будьте готовы, что в любом случае клонирование и выбор тега займёт некоторое
время:

```sh
cd $REPOS
# Экономим время копирования
git clone --depth 1 https://github.com/llvm/$LL_SLUG.git && cd $LL_SLUG
git config --add remote.origin.fetch '^refs/heads/tags/'$LL_REF
git fetch origin refs/tags/$LL_REF
git checkout $LL_REF
```

> TODO: ограничить по скачиванию так же остальные релевантные репозитории

Если вы случайно скачали лишные коммиты, репозиторий можно почистить следующим
образом:

```sh
git tag -d $(git tag -l)
# Возможно потребуется сделать git pull
#git pull --depth 1
git gc --prune=all
```

## Сборка LLVM

Весь `llvm` будет собрать нереально. Это займёт минимум сутки на компьютере
с 4-я `Gb` памяти и 4-мя ядрами `Intel(R) Pentium(R) 3.60GHz`.
`alias` `ll16config` включает параметр: `-DLLVM_ENABLE_PROJECTS=clang`,
который активирует только проект `clang`. Но и это тединственный проект будет
собираться не менее пары часов. Запустите подготовку к сборке:

Для сборки проекта `clang` вам потребуется минимум 8 `Gib` `Swap`-а при 4
`Gib` `ОЗУ`, при этом вся память будет постепенно утекать, исчерпывая себя
к в процессе. При сборке сразу включите `htop` в отдельном окне. Когда `Swap`
окажется занят более чем на `90%` останавливайте сборку нажатием `Ctrl + c`
в соответствующем терминале, и сразу запускайте заново. Процесс сборки
инкрементален, соответсвенно каждый раз будет продолжен с момента остановки.

```sh
cd $BUILDS/$LL_SLUG
# Запускаем сборку
ll16config
```

Если же вы решите настроить сборку всех проектов, то на следующем этапе вы
можете выбрать определённую цель, и собрать именно её:

```sh
# Вывидете спиок целей
cmake --build . --target help | less
# Соберите нужную цель
cmake --build build -- <TARGET>
```

> TODO: почему то при выводе целей нет `clang`, понять как это работает

Если же вы использовали `LLVM_ENABLE_PROJECTS`, то запустите процесс сборки, и
затем установки:

```sh
make -j$(nproc)
sudo make install
```

Сборка займёт несколько часов или более.

# Полезные ссылки

* [README репозитория Qt][4]

[1]: https://code.qt.io/cgit/qt/qt5.git/tree/README.git
[3]: https://myprogrammingnotes.com/build-qt-ssl-support.html
[4]: https://code.qt.io/cgit/qt/qt5.git/refs/
[5]: https://opencv.org/
