> Carthago delenda est!

# VimIDE

Тут я расскажу как превратить `vim` в `IDE` для `C++`-ных программ.

> `CtrlK` Пока ещё полностью не запустился, но `Termdebug` работает штатно

## Vim

Сначала пройдите святой `vimtutor`.

Помощь по конкретному разделу вызывается командой `:h <раздел>`.

Когда открываете помощь, увидите как бы ссылки, они не кликабельны,
это оглавление и `slug`-и глав. Эти `slug`-и используются так же, как опция при вызове `:h`.

Например:

```vim
:h vundle
:h vundle-intercative
```

Для вывода главной справки на русском:

```sh
$ export LANG=ru_RU.UTF8
$ man vim
# Или
$ man -L ru vim
```

Конфигурация `vim` для пользователя хранится в файле `$HOME/.vimrc`, настоятельно рекомендуем добавить автонумерцию строк, комметарий в `.vimrc` - двойные кавычки: `"`:

```vim
" Нумерация строк
set nu
" Четыре пробела заместо таба
set tabstop=4 shiftwidth=4 expandtab
" Заприщает vi вместо vim
set nocompatible " be iMproved, required
" Интеграция мыши
set mouse=a
```

В `Vim` интегрирована [поддержка][18] `Python`-а, что можно узанть вызвав `vim --version`, и найдя в выводе: `+python`, `+python3`. Если заместо `+` стоит `-`, значит какая то поддержка отсутствует.

---
Полезные команды `vim`:

* `:%!xxd` - вывод шестнадцатиричного представления
* `Ctrl` + `G` - показать имя данного файла

Некоторые полезные моменты:

* Русские страницы `man`-а по раполагаются адресу: `/usr/share/man/ru/man1`
* Навигация вперёд-назад: `Ctrl + T`, `Ctrl + O`
* В `Vim` есть команда `python` которая всегда вызывает `python2` и есть команда `python3`
* Файлы плагинов `Vim` имеют расширение `.vim`

Если вы хотите установить локальную конфигурацию пользователя, добавьте раздел `[user]` в `.git/config`. Если вы хотите изменить имя коммитера в уже существующем коммите: `git commit --amend --reset-author  -m "<messsage>"`.

В `Vim` можно интегрировать мышку. Тогда кнопки `toolbar`-ов и ссылки будут кликабельны.
Для этого задайте `set mouse=a`. Если вы хотите скопировать текст как раньше, быз интеграции мыши, так что бы текст попал во внешний буффер обмена, выделяйте текст с нажатой клавишей `Shift`. Не отпускайте `Shift` и нажмите на правую клавишу мыши, для вызова контекстного меню.

При выделении и копировании очень удобно отключить нумерацию строк: `:set nonum`.

Стоит отменить `less` подобный вывод `git branch`:

```sh
# Отменяем less подобное поведение git branch
$ git config --global pager.branch false
```

## Vundle

У `Vim` есть святой манагер плагинов: [`Vundle`][15]. Установите его с помощью:
`git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim`

Плагитны `git`-а должны храниться в папке `~/.vim/bundle/`. `Vundle` работает с плагинами
в формате `git` репозитория.

При разработке плагина, изменяйте его прямо в папке `~/.vim/bundle/<plugin>` и только уже готовую версию грузите в репозиторий. Постоянные `:PluginClean`, `:PluginInstall` при разработке, это не вариант, так как требуют слишком много телодвижений.

Вот необходимая конфигурация для `Vundle`:

```vim
filetype off                  " required
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'
Plugin <Plugin1>
Plugin <PluginN>
"Plugin 'file:///home/olga/repos/CtrlK'
call vundle#end()            " required
filetype plugin indent on    " required
```

Как вы понимаете плагины добавляются в строках начинающихся с `Plugin`.

Рекомендуется установить:

1. FuzzyFinder
2. L9

Удаление плагина просиходит только если вы удалите строку из `.vimrc`, добавление если добавите.

Вот некоторые команды `Vundle`, они основаны на списке плагинов получаемом из `.vimrc`:

1. `:PluginInstall` - Устанавливает плагины которых нет в `~/.vim/bundle/<plugin>`
2. `:PluginUpdate` - Обновляет
3. `:PluginClean` - Удаляет плагины представления которых нет в `.vimrc`

## Termdebug

Вопервых ознакомьтесь с некоторыми мануалами:

* [Debugging in Vim][9]
* [Debugging C++ Programs in Vim][10]

К сожалению я не нашла официальной документации `Termdebug` в интернете, но есть два иных источника:

1. Официальная документация вызываемая с помощью: `:h terminal-debug`
2. В общем вы можете найти все команды в самом коде плагина [тут][1], в коде в клоне репозитория `Vim`

> `:h terminal-debug` обязательно к прочтению!

Отлаживаемая программа должна быть скомпилирована с опцией `-g` переданной в `gcc`. Если вы собираете с `CMake`,
то `CMAKE_BUILD_TYPE` должен быть одним из:

* `Debug`
* `RelWithDebInfo`

В `.vimrc` следует установить следующие опции:

```vim
packadd termdebug
let g:termdebug_wide=1
```

Таким образом мы:

1. Активируем termdebug
2. Создаём горизонтальное разделение экранов

Там же установите сопоставление горячих клавишь для отладки. Я использовала свои настройки, но вы можете их переопределить. Далее по мануалу я буду ссылаться к своим настройкам:

```vim
map <C-F5> :Run<CR>
map <F5> :Continue<CR>
map <F7> :Over<CR>
map <F8> :Step<CR>
map <F6> :Finish<CR>
map <F9> :Break<CR>
map <S-F9> :Clear<CR>
```

* Мы используем `Shift` в `<S-F9>`, так как `<С-F9>` зарезервирован в `OpenSuse`
* Не стоить мапить `:Termdebug`, так как удобнее, используя автозаполнение вызвать`:Termdebug /path/to/executable` и сэкономить на написании `file /path/to/executable` в окне `gdb`, с другой стороны можно замапить прямо с именем экзешника

Обратите внимание на `<CR>` вконце каждого сопоставления. Эта конструкция позволяет сразу запустить команду, иначе вам придётся вручную нажимать `Enter`.

Немного о командах, их три категории. При активации определйнного окна, становятся доступными первые две категории команд, третья категория доступна всегда, но будет влиять на активное окно

1. Команды `Vim` набранные при активном окне кода в режиме команд (`Esc`)
2. Команды `Gdb` набранные при активном окне `Gdb` в терминале
3. Команды перехода между окнами и изменения размеров окон

В `Vim` открываем нужный файл, командой `:o`, запускаем отладчик, командой `:Termdebug`

> В режиме команд `Vim` работает автозаполнение табуляцией и сокращения команд

Переключаемся между окнами комбинацией:

`Ctrl + w`, отпускаем и нажимаем одну из клавиш: `[вверх, вниз, впрао, влево]`.

Иногда удобнее будет нажать `Ctrl + w + w` для движения против часовой стрелки (не знаю как по часовой).

Перед вами три окна:

1. Верхнее слева: окно `Gdb`
2. Нижнее слева: *окно терминала программы*
3. Справа: окно кода

![Termdebug](doc/img/termdebug.jpg)

Возможно будет удобно уменьшить *окно терминала программы* комбинацией или расширить окно кода, вот комбинации. Для необходимого эффекта следует выполнить многократно:

* Уменьшить по вертикали: `Ctrl + w` отпускаем и нажимаем `-`
* Увеличить по вертикали: `Ctrl + w` отпускаем и нажимаем `+`
* Увеличить по горизонтали: `Ctrl + w` отпускаем и нажимаем `<` (`Shift + ,`)
* Уменьшить по горизонтали: `Ctrl + w` отпускаем и нажимаем `>` (`Shift + .`)

Так же в режиме команд в окне кода можно использовать:

* `:30winc >` - увеличиваем ширину на 30
* `:30winc <` - уменьшаем ширину на 30
* `:resize 30` - выставляем высоту в 30

> При переходе внутрь функции, если функция в другом файле, `Gdb` автоматом откроет этот файл.

При активации *окна терминала программы*, ввод будет передан непосредственно в запущенный и отлаживаемый процесс.

Далее:

1. В окне `Gdb` загружаем файл командой `file path/to/bin`
2. Выставляем точки останова дойдя до нужной строки и вызвав `F9`
3. Вызываем `run` в окне `Gdb`

Начинаем дебажить используя `F5`, `F7`, `F8`.

> Возможно будут некоторые проблемы, так как установленная по умолчанию версия `Vim`,
> это: `8.0`; при этом пишут, что нужна версия `8.1`

Для вывода панели комманд, необходимо вызвать `:Winbar`.

Вот список команд и их значений

1. `:Step` - войти в функцию
2. `:Over` - не входить в функцию
3. `:Finish` - предположительно выходим из функции, но возможно отключаемся от процесса (уточнить)
4. `:Continue` - продолжить до следующей точки останова
5. `:Stop` - предположительно послать сигнал `kill` (уточнить)
6. `:Break` - установить точку останова
7. `:Clear` - убрать точку останова
8. `:Run` - начать запуск
9. `:Winbar` - мышевое `gui` меню отладчика

Все те же действия вы можете выполнить из окна `Gdb`. Например установка точки останова на 25 строке выполняется с помощью `b 25`, а переход на следующую команду: `n` и `ni` (уточнить по поводу перехода с вхождением и без).

Для выхода из режима отладки, вводим `quit` в окне `Gdb`

## CtrlK

В `Vim` можно настроить навигацию по коду в `C++` по вот этому [святому мануалу][14].

По указанным ссылкам находятся устаревшие проекты, которые нельзя собрать в наши дни,
в связи с этим я портировала эти проекты на `Python3`:

1. [`py-ctrlk`][16]
2. [`CtrlK`][17]

Склонируйте оба репозитория.

Установите `so`-шный `clang`: `sudo zypper install libclang libclang-devel`

Посмотрите какая версия установилась: `locate libclang`.

Далее установите `python`-овский `clang`, но соответсвущей версии: `pip install clang=<VER>`. Если до этого, вы установили ошибочную версию, используйте: `pip uninstall clang`.

`Python`-овский `clang` просит `so`-шник в формате `libclang-<VER>.so`, а мы имеем формат `libclang.so.<VER>`. Перейдите в папку `/usr/lib64` и выполните: `sudo ln -s libclang.so.<VER> libclang-<VER>.so`, давлее `sudo ldconfig`.

Собирите и установите `py-ctrlk`, как указанно в мануале:

```sh
$ python setup.py build
$ sudo python setup.py install
```

В конфигурации `Vundle` заместо `Plugin 'SkidanovAlex/CtrlK'`
напишите: `Plugin 'file:///home/<user>/repos/CtrlK'` заменяя `<user>` на своего пользователя, если склонировали репозиторий `CtrlK` в `/home/<user>/repos/CtrlK`.

Не прописывайте опцию: `let g:ctrlk_clang_library_path="/home/user/llvm/lib"`, так как `py-ctrlk` собран с актуальным и доступным из системы `libclang`-ом.

> Возможно вам всё таки придётся установить его в `let g:ctrlk_clang_library_path="/usr/lib64"`

Задайте клавиши для основных команд `CtrlK`:

```vim
nmap <F3> :call GetCtrlKState()<CR>
nmap <C-k> :call CtrlKNavigateSymbols()<CR>
nmap <F4> :call CtrlKGoToDefinition()<CR>
nmap <F12> :call CtrlKGetReferences()<CR>
```

Запустите тесты в репозитории `py-ctrlk`:

```sh
$ cd test
$ ./test.py
```

> Так же есть `try.py`, но его необходимо доработать, тк он входит в вечный цикл

Я добавила два скрипта:
1. `kill.sh` - убивает сервер `ctrlk`
2. `rebuild.sh` - пересобирает и публикует модуль

> Модуль в процессе портирования, и пока не работает.

Для отладки `Python`-а в модуле, используйте следующую конструкцию:

```py
with open('/path/to/log', 'a') as the_file:
	the_file.write('info line\n')
```

Так же добавила функцию `MyRequestHandler.write_error` результат которой должен оказываться в `vim` в статусной сроке. Но функция пока тоже не работает как ожидается.

На данный момент удалось пройти следующую строку в файле `client_api.py`

```py
indexer.start(self.leveldb_connection, n_workers)
```

**Как только этот проект поднимиться, это будет нечто фантастическое!**

[1]: https://github.com/vim/vim/blob/master/runtime/pack/dist/opt/termdebug/plugin/termdebug.vim
[9]: https://medium.com/swlh/debugging-c-programs-in-vim-683ec257b9e2
[10]: https://www.dannyadam.com/blog/2019/05/debugging-in-vim/
[16]: https://github.com/olgapshen/py-ctrlk
[17]: https://github.com/olgapshen/CtrlK
[15]: https://github.com/VundleVim/Vundle.vim
[14]: https://habr.com/ru/post/245681/
[18]: https://netdotwork.github.io/vim-python/
