> Carthago delenda est!

# VimIDE

Тут я расскажу о работе в интерактивной консольной среде. О том как превратить
`vim` в `IDE` для `C++`-ных, а так же об утилитах как `Lynx` и `Mutt`.

> В этом мануале используется `zypper` в качестве системы управления пакетами,
> однако команда в конечном счёте зависит от вашего дистрибутива

> `CtrlK` Пока ещё полностью не запустился, но `Termdebug` работает штатно

# Оглавление

- [VimIDE](#vimide)
- [Оглавление](#оглавление)
- [Lynx](#lynx)
- [Mutt](#mutt)
- [Vim](#vim)
- [Vundle](#vundle)
- [Gdb](#gdb)
- [Termdebug](#termdebug)
- [CtrlK](#ctrlk)

# Lynx

Для проверки доступа к сайтам и проверки `ssl` вам стоит установить `lynx`.

> В общем доступность `ssl` и вообще доступность сайта можно проверить и с
> помощью: `curl [-k] -vvI https://domain.org`, а затем скачать и установить
> сертификат с помощью `openssl s_client`, как описано в проекте
> [`Нибелунги`](../nibelungen/README.md), но `Lynx` по истене великая вещь,
> которая сыграет ещё свою роль в вашем таинственном труде
> `sys`прога/`dep`опса, в вашей борьбе невидимого фронта, особенно при создании
> образов `Docker`-а

Для перехода на адресс, нажмите `g` и введите или вставьте `url`, затем
`Enter`.

Вы можете производить навигацию по странице с помщью клавишь
`[вниз, вверх, влево, вправо]`, а так же `Tab`. При заполнении полей форм,
`Lynx` сам распознаёт тип поля: `checkbox`, `text` и тд.

`Lynx` спросит вас разрешение на скачивание `cookie` и прочей информации.

Для выхода `q`.

В общем всё очень похоже на `Vim`.

# Mutt

В терминале присутствуют несколько сред для работы с почтой. Очень удобная
среди них: `mutt`. Но при вызове собственно говоря команды `mail` вы окажетесь
в ещё более простой интерактивной среде.

При вызове, следует передать параметр `-N`б что бы не печатать заголовки
метаданных писем:

```sh
# опустить заголовок писем
mail -N
```

* Вы окажетесь в режиме спика писем. Используйте `z` для движения впрёд по
  списку
* Если в ыначали редактировать письмо, используйте `Ctrl + d` для завершения
  ввода текста
* Для удаления всех писем, используйте `d *`
* Для помощи используйте `help`
* Для выхода `quit`

# Vim

Сначала пройдите святой `vimtutor`.

Помощь по конкретному разделу вызывается командой `:h <раздел>`.

Когда открываете помощь, увидите как бы ссылки, они не кликабельны,
это оглавление и `slug`-и глав. Эти `slug`-и используются так же, как опция
при вызове `:h`.

Например:

```vim
:h vundle
:h vundle-intercative
```

Для вывода главной справки на русском:

```sh
export LANG=ru_RU.UTF8
man vim
# Или
man -L ru vim
```

Конфигурация `vim` для пользователя хранится в файле `HOME/.vimrc`,
настоятельно рекомендуем добавить автонумерцию строк, комметарий в `.vimrc` -
двойные кавычки: `"`:

> Решить по поводу опций `smarttab` и `expandtab`

```vim
" Нумерация строк
set nu
" Четыре пробела заместо таба
set tabstop=4 shiftwidth=4 smarttab
" Заприщает vi вместо vim
set nocompatible " be iMproved, required
" Интеграция мыши
set mouse=a
```

В `Vim` интегрирована [поддержка][18] `Python`-а, что можно узанть вызвав
`vim --version`, и найдя в выводе: `+python`, `+python3`. Если заместо `+`
стоит `-`, значит какая то поддержка отсутствует.

---
Полезные команды `vim`:

* `:%!xxd` - вывод шестнадцатиричного представления
* `Ctrl` + `G` - показать имя данного файла

Некоторые полезные моменты:

* Русские страницы `man`-а по раполагаются адресу: `/usr/share/man/ru/man1`
* Навигация вперёд-назад: `Ctrl + T`, `Ctrl + O`
* В `Vim` есть команда `python` которая всегда вызывает `python2` и есть
  команда `python3`
* Файлы плагинов `Vim` имеют расширение `.vim`

Если вы хотите установить локальную конфигурацию пользователя, добавьте раздел
`[user]` в `.git/config`. Если вы хотите изменить имя коммитера в уже
существующем коммите: `git commit --amend --reset-author  -m "<messsage>"`.

В `Vim` можно интегрировать мышку. Тогда кнопки `toolbar`-ов и ссылки будут
кликабельны. Для этого задайте `set mouse=a`. Если вы хотите скопировать текст
как раньше, быз интеграции мыши, так что бы текст попал во внешний буффер
обмена, выделяйте текст с нажатой клавишей `Shift`. Не отпускайте `Shift` и
нажмите на правую клавишу мыши, для вызова контекстного меню.

При выделении и копировании очень удобно отключить нумерацию строк:
`:set nonum`.

Стоит отменить `less` подобный вывод `git branch`:

```sh
# Отменяем less подобное поведение git branch
git config --global pager.branch false
```

Для того, что бы добавить несколько `url`-ов для в качестве `upstream`:

```sh
git remote set-url origin --push --add url-one
git remote set-url origin --push --add url-two
```

# Vundle

У `Vim` есть святой манагер плагинов: [`Vundle`][15]. Установите его с помощью:

```sh
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
```

Плагитны `git`-а должны храниться в папке `~/.vim/bundle/`. `Vundle` работает
с плагинами в формате `git` репозитория.

При разработке плагина, изменяйте его прямо в папке `~/.vim/bundle/<plugin>` и
только уже готовую версию грузите в репозиторий. Постоянные `:PluginClean`,
`:PluginInstall` при разработке, это не вариант, так как требуют слишком много
телодвижений.

Вот необходимая конфигурация для `Vundle`. Добавьте следующие строки в
`~/.vimrc`:

```vim
filetype off                  " required
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'
Plugin <Plugin1>
Plugin <PluginN>
"Plugin 'file:///.../CtrlK'
call vundle#end()            " required
filetype plugin indent on    " required
```

Как вы понимаете плагины добавляются в строках начинающихся с `Plugin`. Каждый
идентификатор плагина должен быть обрамлён одинарной кавычкой. В зависимости от
указания имени плагина, плагин ищется в следующих местах:

| Формат имени           | Пример                 | Область поиска       |
| ---------------------- | ---------------------- | -------------------- |
| несколько частей `uri` | `VundleVim/Vundle.vim` | В корне `github` (1) |
| один `slug`            | `FuzzyFinder`          | В `vim-script` (2)   |
| начинается с `file://` | `file:///.../CtrlK`    | Локально             |

(1) `https://github.com/`\
(2) `https://github.com/vim-script`

Рекомендуется установить следующие плагины из `vim-script`:

1. `FuzzyFinder`
2. `L9`

Удаление плагина просиходит только если вы удалите строку из `.vimrc`,
добавление если добавите.

Вот некоторые команды `Vundle`, они основаны на списке плагинов получаемом из
`.vimrc`:

1. `:PluginInstall` - Устанавливает плагины (1)
2. `:PluginUpdate` - Обновляет
3. `:PluginClean` - Удаляет плагины (2)

(1) Плагины которых нет в `~/.vim/bundle/<plugin>`\
(2) Плагины представления которых нет в `.vimrc`

# Gdb

Перед тем, как мы начнём пользоваться плагином `Termdebug` для `Vim`,
стоит освоить чистый `GDB` из командной строки.

Используйте следующие команды:

* `file` для загрузки запускаемого файла или динамической библиотеки
* `break` для точки останова
* `step` для входа в функцию
* `next` для шага без входа
* `finish` для выхода из функции
* `display` для вывода значения выражений
* `kill` для досрочного завершения процесса

Все команды можно сокращать до минимальной уникальной последовательности.

| Команда  | Сокращение |
| -------- | ---------- |
| `break`  | `b`        |
| `step`   | `s`        |
| `next`   | `n`        |
| `finish` | `f`        |

Для `break` передайте в качестве аргумента имя файла и через двоеточие номер
строки. Полный путь можно опустить. При выводе строк с помощью `display` при
нераспознанной кодировке, вы получите удобный вывод в восмиричном формате:

> person->name = "\123\123\123\123 \123\123\123\123\123\123\123\123"

Все библиотеки и запускаемый файлы должны быть собраны с ключём `g++` `-g` для
включения символов отладки.

Пример сессии.

```sh
gdb
> file programm
> file common.so
> break main.cpp:353
> break common.cpp:157
> s
> n
> f
> display person->name
> kill
```

# Termdebug

Вопервых ознакомьтесь с некоторыми мануалами:

* [Debugging in Vim][9]
* [Integrate GDB With Vim][2]

К сожалению я не нашла официальной документации `Termdebug` в интернете, но
есть два иных источника:

1. Официальная документация вызываемая с помощью: `:h terminal-debug`
2. В общем вы можете найти все команды в самом коде плагина [тут][1], в коде в
   клоне репозитория `Vim`

> `:h terminal-debug` обязательно к прочтению!

Отлаживаемая программа должна быть скомпилирована с опцией `-g` переданной в
`gcc`. Если вы собираете с `CMake`, то `CMAKE_BUILD_TYPE` должен быть одним из:

* `Debug`
* `RelWithDebInfo`

В `.vimrc` следует установить следующие опции:

```vim
packadd termdebug
let g:termdebug_wide=1
```

Таким образом мы:

1. Активируем `termdebug`
2. Создаём горизонтальное разделение экранов

Там же установите сопоставление горячих клавишь для отладки. Я использовала
свои настройки, но вы можете их переопределить. Далее по мануалу я буду
ссылаться к своим настройкам:

```vim
map <C-F5> :Run<CR>
map <F5> :Continue<CR>
map <F7> :Over<CR>
map <F8> :Step<CR>
map <F6> :Finish<CR>
map <F9> :Break<CR>
map <S-F9> :Clear<CR>
```

> Мы используем `Shift` в `<S-F9>`, так как `<С-F9>` зарезервирован в
> `OpenSuse`; Не стоить мапить `:Termdebug`, так как удобнее, используя
> автозаполнение вызвать `:Termdebug /path/to/executable` и сэкономить на
> написании `file /path/to/executable` в окне `gdb`, с другой стороны можно
> замапить прямо с именем экзешника

Обратите внимание на `<CR>` вконце каждого сопоставления. Эта конструкция
позволяет сразу запустить команду, иначе вам придётся вручную нажимать `Enter`.

Вот в общем список команд и их значеня:

1. `:Step` - войти в функцию
2. `:Over` - не входить в функцию
3. `:Finish` - предположительно выходим из функции (1)
4. `:Continue` - продолжить до следующей точки останова
5. `:Stop` - предположительно послать сигнал `kill` (уточнить)
6. `:Break` - установить точку останова
7. `:Clear` - убрать точку останова
8. `:Run` - начать запуск
9. `:Evaluate {expression}` - расчитать значение
10. `:Winbar` - мышевое `gui` меню отладчика

* (1) возможно отключаемся от процесса (TODO: уточнить)

Немного о командах, их три категории. При активации определйнного окна,
становятся доступными первые две категории команд, третья категория доступна
всегда, но будет влиять на активное окно:

1. Команды `Vim` набранные при активном окне кода в режиме команд (`Esc`)
2. Команды `Gdb` набранные при активном окне `Gdb` в терминале
3. Команды перехода между окнами и изменения размеров окон

> В режиме команд `Vim` работает автозаполнение табуляцией и сокращения команд

В `Vim` открываем нужный файл командой `:o`. Затем запускаем отладчик командой
`:Termdebug`. Переключаемся между окнами следующим образом. Вызываем
комбинацию `Ctrl + w`, затем отпускаем и нажимаем одну из клавиш:
`[вверх, вниз, впрао, влево]`. Так же можно нажать `Ctrl + w + w` для движения
против часовой стрелки. `Ctrl + w + l` - переход на окно с кодом.

Команды `vim` в общем то можнозапускать лишь при фокусировке на правом окне с
кодом. При открытия дополнительных файлов командой `:o` в режиме отладчика
автозаполнение работать не будет, но вы можете написать лишь папку, и `vim`
выведет вам проводник, где вы с помошью навигации сможете выбрать нужный файл.

Перед вами три окна:

1. Верхнее слева: окно `Gdb`
2. Нижнее слева: *окно терминала программы*
3. Справа: окно кода

![Termdebug](doc/img/termdebug.jpg)

Возможно будет удобно уменьшить *окно терминала программы* комбинацией или
расширить окно кода, вот комбинации. Для необходимого эффекта следует
выполнить многократно:

* Уменьшить по вертикали: `Ctrl + w` отпускаем и нажимаем `-`
* Увеличить по вертикали: `Ctrl + w` отпускаем и нажимаем `+`
* Увеличить по горизонтали: `Ctrl + w` отпускаем и нажимаем `<` (`Shift + ,`)
* Уменьшить по горизонтали: `Ctrl + w` отпускаем и нажимаем `>` (`Shift + .`)

Так же в режиме команд в окне кода можно использовать:

* `:30winc >` - увеличиваем ширину на 30
* `:30winc <` - уменьшаем ширину на 30
* `:resize 30` - выставляем высоту в 30

> При переходе внутрь функции, если функция в другом файле, `Gdb` автоматом
> откроет этот файл

При активации *окна терминала программы*, ввод будет передан непосредственно в
запущенный и отлаживаемый процесс. Далее:

1. В окне `Gdb` загружаем файл командой `file path/to/bin`
2. Выставляем точки останова дойдя до нужной строки и вызвав `F9`
3. Вызываем `run` в окне `Gdb`

Начинаем дебажить используя `F5`, `F7`, `F8`. Соответствия смотрите выше. Для
вывода панели комманд, необходимо вызвать `:Winbar`.

Расчёт значения выполняется с помощью команды `:Evaluate {expression}`. Без
выражения расчитается значение под курсором. Такой же эфект будет при нажатии
`Shift + k`.

Пришло время более подробно ознакомиться с документацией по плагину:

```vim
:help terminal-debug
```

> Возможно будут некоторые проблемы, так как установленная по умолчанию версия
> `Vim`, это: `8.0`; при этом пишут, что нужна версия `8.1`

Все те же действия вы можете выполнить из окна `Gdb`. Например установка точки
останова на 25 строке выполняется с помощью `b 25`, а переход на следующую
команду: `n` и `ni` (уточнить по поводу перехода с вхождением и без).

Для выхода из режима отладки, вводим `quit` в окне `Gdb`

# CtrlK

В `Vim` можно настроить навигацию по коду в `C++` по вот этому
[святому мануалу][14].

По указанным ссылкам находятся устаревшие проекты, которые нельзя собрать в
наши дни, в связи с этим я портировала эти проекты на `Python3`:

1. [`py-ctrlk`][16]
2. [`CtrlK`][17]

Склонируйте оба репозитория. Установите пакет разработки `python3`:

```sh
sudo zypper install python311-devel
```

Тем или иным образом установите `libclang-devel`. Если в текущем состоянии
вашего дистрибутива у вас нет необходимых пакетов, собирите `llvm` по
[инструкции](../opensuse/README.md#llvm) в часте посвещённой `OpenSUSE`.

Найдите версию вашей сборки `libclang`, если вы устанавливали через систему
управления пакетами, то воспользуйтесь одной из следующих команд:

```sh
# С помощью locate, если вы создали соответствующую базу
locate libclang
# С помощью zypper
zypper packages --installed-only | grep libclang
```

Если же вы собирали собственную сборку, то версия закодирована в использованном
теге `git`-а.

Перейдите в репозиторий `py-ctrlk`, создайте виртуальную среду, активируйте её:

```sh
python3 -m venv .venv
source .venv/bin/activate
```

Далее установите `python`-овский `clang`. Перед этим найдите соответствующую
версию:

```sh
pip index versions clang
pip install clang==<VER>
```

Если до этого, вы установили ошибочную версию, используйте:

```sh
pip uninstall clang
```

> TODO: актуализировать

`Python`-овский `clang` просит `so`-шник в формате `libclang-<VER>.so`, а мы
имеем формат `libclang.so.<VER>`. Перейдите в папку `/usr/lib64` и выполните:
`sudo ln -s libclang.so.<VER> libclang-<VER>.so`, давлее `sudo ldconfig`.

Собирите и установите `py-ctrlk`, как указанно в мануале:

```sh
python setup.py build
sudo python setup.py install
```

В конфигурации `Vundle` заместо `Plugin 'SkidanovAlex/CtrlK'`
напишите: `Plugin 'file:///home/<user>/repos/CtrlK'` заменяя `<user>` на
своего пользователя, если склонировали репозиторий `CtrlK` в
`/home/<user>/repos/CtrlK`.

Не прописывайте опцию: `let g:ctrlk_clang_library_path="/home/user/llvm/lib"`,
так как `py-ctrlk` собран с актуальным и доступным из системы `libclang`-ом.

> Возможно вам всё таки придётся установить его в
> `let g:ctrlk_clang_library_path="/usr/lib64"`

Задайте клавиши для основных команд `CtrlK`:

```vim
nmap <F3> :call GetCtrlKState()<CR>
nmap <C-k> :call CtrlKNavigateSymbols()<CR>
nmap <F4> :call CtrlKGoToDefinition()<CR>
nmap <F12> :call CtrlKGetReferences()<CR>
```

Запустите тесты в репозитории `py-ctrlk`:

```sh
cd test
./test.py
```

> Так же есть `try.py`, но его необходимо доработать, тк он входит в
> бесконечный цикл

Я добавила два скрипта:
1. `kill.sh` - убивает сервер `ctrlk`
2. `rebuild.sh` - пересобирает и публикует модуль

> Модуль в процессе портирования, и пока не работает.

Для отладки `Python`-а в модуле, используйте следующую конструкцию:

```py
with open('/path/to/log', 'a') as the_file:
	the_file.write('info line\n')
```

Так же добавила функцию `MyRequestHandler.write_error` результат которой
должен оказываться в `vim` в статусной сроке. Но функция пока тоже не работает
как ожидается.

На данный момент удалось пройти следующую строку в файле `client_api.py`

```py
indexer.start(self.leveldb_connection, n_workers)
```

**Как только этот проект поднимиться, это будет нечто фантастическое!**

[1]: https://github.com/vim/vim/blob/master/runtime/pack/dist/opt/termdebug/plugin/termdebug.vim
[2]: https://www.baeldung.com/linux/vim-gdb-integration
[9]: https://www.dannyadam.com/blog/2019/05/debugging-in-vim/
[16]: https://github.com/olgapshen/py-ctrlk
[17]: https://github.com/olgapshen/CtrlK
[15]: https://github.com/VundleVim/Vundle.vim
[14]: https://habr.com/ru/post/245681/
[18]: https://netdotwork.github.io/vim-python/
